<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/underscore.string/test/test_underscore/vendor/qunit.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/underscore.string/test/test_underscore/vendor/qunit.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2350</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">204.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">26.34</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * QUnit - A JavaScript Unit Testing Framework
 *
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2009 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var QUnit = {

	// Initialize the configuration options
	init: function init() {
		config = {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			blocking: false,
			autorun: false,
			assertions: [],
			filters: [],
			queue: []
		};

		var tests = id(&quot;qunit-tests&quot;),
			banner = id(&quot;qunit-banner&quot;),
			result = id(&quot;qunit-testresult&quot;);

		if ( tests ) {
			tests.innerHTML = &quot;&quot;;
		}

		if ( banner ) {
			banner.className = &quot;&quot;;
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},

	// call on start of module test to prepend name to all tests
	module: function module(name, testEnvironment) {

		synchronize(function() {
			if ( config.currentModule ) {
				QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all );
			}

			config.currentModule = name;
			config.moduleTestEnvironment = testEnvironment;
			config.moduleStats = { all: 0, bad: 0 };

			QUnit.moduleStart( name, testEnvironment );
		});
	},

	asyncTest: function asyncTest(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},

	test: function test(testName, expected, callback, async) {
		var name = testName, testEnvironment = {};

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = config.currentModule + &quot; module: &quot; + name;
		}

		if ( !validTest(name) ) {
			return;
		}

		synchronize(function() {
			QUnit.testStart( testName );

			testEnvironment = extend({
				setup: function() {},
				teardown: function() {}
			}, config.moduleTestEnvironment);

			config.assertions = [];
			config.expected = null;

			if ( arguments.length &gt;= 3 ) {
				config.expected = callback;
				callback = arguments[2];
			}

			try {
				if ( !config.pollution ) {
					saveGlobal();
				}

				testEnvironment.setup.call(testEnvironment);
			} catch(e) {
				QUnit.ok( false, &quot;Setup failed on &quot; + name + &quot;: &quot; + e.message );
			}

			if ( async ) {
				QUnit.stop();
			}

			try {
				callback.call(testEnvironment);
			} catch(e) {
				fail(&quot;Test &quot; + name + &quot; died, exception and test follows&quot;, e, callback);
				QUnit.ok( false, &quot;Died on test #&quot; + (config.assertions.length + 1) + &quot;: &quot; + e.message );
				// else next test will carry the responsibility
				saveGlobal();

				// Restart the tests if they&#039;re blocking
				if ( config.blocking ) {
					start();
				}
			}
		});

		synchronize(function() {
			try {
				checkPollution();
				testEnvironment.teardown.call(testEnvironment);
			} catch(e) {
				QUnit.ok( false, &quot;Teardown failed on &quot; + name + &quot;: &quot; + e.message );
			}

			try {
				QUnit.reset();
			} catch(e) {
				fail(&quot;reset() failed, following Test &quot; + name + &quot;, exception and reset fn follows&quot;, e, reset);
			}

			if ( config.expected &amp;&amp; config.expected != config.assertions.length ) {
				QUnit.ok( false, &quot;Expected &quot; + config.expected + &quot; assertions, but &quot; + config.assertions.length + &quot; were run&quot; );
			}

			var good = 0, bad = 0,
				tests = id(&quot;qunit-tests&quot;);

			config.stats.all += config.assertions.length;
			config.moduleStats.all += config.assertions.length;

			if ( tests ) {
				var ol  = document.createElement(&quot;ol&quot;);
				ol.style.display = &quot;none&quot;;

				for ( var i = 0; i &lt; config.assertions.length; i++ ) {
					var assertion = config.assertions[i];

					var li = document.createElement(&quot;li&quot;);
					li.className = assertion.result ? &quot;pass&quot; : &quot;fail&quot;;
					li.innerHTML = assertion.message || &quot;(no message)&quot;;
					ol.appendChild( li );

					if ( assertion.result ) {
						good++;
					} else {
						bad++;
						config.stats.bad++;
						config.moduleStats.bad++;
					}
				}

				var b = document.createElement(&quot;strong&quot;);
				b.innerHTML = name + &quot; &lt;b style=&#039;color:black;&#039;&gt;(&lt;b class=&#039;fail&#039;&gt;&quot; + bad + &quot;&lt;/b&gt;, &lt;b class=&#039;pass&#039;&gt;&quot; + good + &quot;&lt;/b&gt;, &quot; + config.assertions.length + &quot;)&lt;/b&gt;&quot;;

				addEvent(b, &quot;click&quot;, function() {
					var next = b.nextSibling, display = next.style.display;
					next.style.display = display === &quot;none&quot; ? &quot;block&quot; : &quot;none&quot;;
				});

				addEvent(b, &quot;dblclick&quot;, function(e) {
					var target = (e || window.event).target;
					if ( target.nodeName.toLowerCase() === &quot;strong&quot; ) {
						var text = &quot;&quot;, node = target.firstChild;

						while ( node.nodeType === 3 ) {
							text += node.nodeValue;
							node = node.nextSibling;
						}

						text = text.replace(/(^\s*|\s*$)/g, &quot;&quot;);

						if ( window.location ) {
							window.location.href = window.location.href.match(/^(.+?)(\?.*)?$/)[1] + &quot;?&quot; + encodeURIComponent(text);
						}
					}
				});

				var li = document.createElement(&quot;li&quot;);
				li.className = bad ? &quot;fail&quot; : &quot;pass&quot;;
				li.appendChild( b );
				li.appendChild( ol );
				tests.appendChild( li );

				if ( bad ) {
					var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
					if ( toolbar ) {
						toolbar.style.display = &quot;block&quot;;
						id(&quot;qunit-filter-pass&quot;).disabled = null;
						id(&quot;qunit-filter-missing&quot;).disabled = null;
					}
				}

			} else {
				for ( var i = 0; i &lt; config.assertions.length; i++ ) {
					if ( !config.assertions[i].result ) {
						bad++;
						config.stats.bad++;
						config.moduleStats.bad++;
					}
				}
			}

			QUnit.testDone( testName, bad, config.assertions.length );

			if ( !window.setTimeout &amp;&amp; !config.queue.length ) {
				done();
			}
		});

		if ( window.setTimeout &amp;&amp; !config.doneTimer ) {
			config.doneTimer = window.setTimeout(function(){
				if ( !config.queue.length ) {
					done();
				} else {
					synchronize( done );
				}
			}, 13);
		}
	},

	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don&#039;t slip through.
	 */
	expect: function expect(asserts) {
		config.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( &quot;asdfasdf&quot;.length &gt; 5, &quot;There must be at least 5 chars&quot; );
	 */
	ok: function ok(a, msg) {
		QUnit.log(a, msg);

		config.assertions.push({
			result: !!a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equals( format(&quot;Received {0} bytes.&quot;, 2), &quot;Received 2 bytes.&quot; );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equals: function equals(actual, expected, message) {
		push(expected == actual, actual, expected, message);
	},

	same: function(a, b, message) {
		push(QUnit.equiv(a, b), a, b, message);
	},

	start: function start() {
		// A slight delay, to avoid any current callbacks
		if ( window.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},

	stop: function stop(timeout) {
		config.blocking = true;

		if ( timeout &amp;&amp; window.setTimeout ) {
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, &quot;Test timed out&quot; );
				QUnit.start();
			}, timeout);
		}
	},

	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 */
	reset: function reset() {
		if ( window.jQuery ) {
			jQuery(&quot;#main&quot;).html( config.fixture );
			jQuery.event.global = {};
			jQuery.ajaxSettings = extend({}, config.ajaxSettings);
		}
	},

	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, &quot;click&quot; );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function triggerEvent( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent(&quot;MouseEvents&quot;);
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent(&quot;on&quot;+type);
		}
	},

	// Logging callbacks
	done: function done(failures, total) {},
	log: function log(result, message) {},
	testStart: function testStart(name) {},
	testDone: function testDone(name, failures, total) {},
	moduleStart: function moduleStart(name, testEnvironment) {},
	moduleDone: function moduleDone(name, failures, total) {}
};

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: &quot;&quot;, protocol: &quot;file:&quot; },
		GETParams = location.search.slice(1).split(&#039;&amp;&#039;);

	for ( var i = 0; i &lt; GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === &quot;noglobals&quot; ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		}
	}

	// restrict modules/tests by get parameters
	config.filters = GETParams;

	// Figure out if we&#039;re running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === &#039;file:&#039;);
})();

// Expose the API as global variables, unless an &#039;exports&#039;
// object exists, in that case we assume we&#039;re in CommonJS
if ( typeof exports === &quot;undefined&quot; || typeof require === &quot;undefined&quot; ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

if ( typeof document === &quot;undefined&quot; || document.readyState === &quot;complete&quot; ) {
	config.autorun = true;
}

addEvent(window, &quot;load&quot;, function() {
	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id(&quot;qunit-userAgent&quot;);
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}

	var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
	if ( toolbar ) {
		toolbar.style.display = &quot;none&quot;;

		var filter = document.createElement(&quot;input&quot;);
		filter.type = &quot;checkbox&quot;;
		filter.id = &quot;qunit-filter-pass&quot;;
		filter.disabled = true;
		addEvent( filter, &quot;click&quot;, function() {
			var li = document.getElementsByTagName(&quot;li&quot;);
			for ( var i = 0; i &lt; li.length; i++ ) {
				if ( li[i].className.indexOf(&quot;pass&quot;) &gt; -1 ) {
					li[i].style.display = filter.checked ? &quot;none&quot; : &quot;block&quot;;
				}
			}
		});
		toolbar.appendChild( filter );

		var label = document.createElement(&quot;label&quot;);
		label.setAttribute(&quot;for&quot;, &quot;filter-pass&quot;);
		label.innerHTML = &quot;Hide passed tests&quot;;
		toolbar.appendChild( label );

		var missing = document.createElement(&quot;input&quot;);
		missing.type = &quot;checkbox&quot;;
		missing.id = &quot;qunit-filter-missing&quot;;
		missing.disabled = true;
		addEvent( missing, &quot;click&quot;, function() {
			var li = document.getElementsByTagName(&quot;li&quot;);
			for ( var i = 0; i &lt; li.length; i++ ) {
				if ( li[i].className.indexOf(&quot;fail&quot;) &gt; -1 &amp;&amp; li[i].innerHTML.indexOf(&#039;missing test - untested code is broken code&#039;) &gt; - 1 ) {
					li[i].parentNode.parentNode.style.display = missing.checked ? &quot;none&quot; : &quot;block&quot;;
				}
			}
		});
		toolbar.appendChild( missing );

		label = document.createElement(&quot;label&quot;);
		label.setAttribute(&quot;for&quot;, &quot;filter-missing&quot;);
		label.innerHTML = &quot;Hide missing tests (untested code is broken code)&quot;;
		toolbar.appendChild( label );
	}

	var main = id(&#039;main&#039;);
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if ( window.jQuery ) {
		config.ajaxSettings = window.jQuery.ajaxSettings;
	}

	QUnit.start();
});

function done() {
	if ( config.doneTimer &amp;&amp; window.clearTimeout ) {
		window.clearTimeout( config.doneTimer );
		config.doneTimer = null;
	}

	if ( config.queue.length ) {
		config.doneTimer = window.setTimeout(function(){
			if ( !config.queue.length ) {
				done();
			} else {
				synchronize( done );
			}
		}, 13);

		return;
	}

	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all );
	}

	var banner = id(&quot;qunit-banner&quot;),
		tests = id(&quot;qunit-tests&quot;),
		html = [&#039;Tests completed in &#039;,
		+new Date - config.started, &#039; milliseconds.&lt;br/&gt;&#039;,
		&#039;&lt;span class=&quot;bad&quot;&gt;&#039;, config.stats.all - config.stats.bad, &#039;&lt;/span&gt; tests of &lt;span class=&quot;all&quot;&gt;&#039;, config.stats.all, &#039;&lt;/span&gt; passed, &#039;, config.stats.bad,&#039; failed.&#039;].join(&#039;&#039;);

	if ( banner ) {
		banner.className += &quot; &quot; + (config.stats.bad ? &quot;fail&quot; : &quot;pass&quot;);
	}

	if ( tests ) {
		var result = id(&quot;qunit-testresult&quot;);

		if ( !result ) {
			result = document.createElement(&quot;p&quot;);
			result.id = &quot;qunit-testresult&quot;;
			result.className = &quot;result&quot;;
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( config.stats.bad, config.stats.all );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}

	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == &#039;!&#039;;

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

function push(result, actual, expected, message) {
	message = message || (result ? &quot;okay&quot; : &quot;failed&quot;);
	QUnit.ok( result, result ? message + &quot;: &quot; + expected : message + &quot;, expected: &quot; + QUnit.jsDump.parse(expected) + &quot; result: &quot; + QUnit.jsDump.parse(actual) );
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun &amp;&amp; !config.blocking ) {
		process();
	}
}

function process() {
	while ( config.queue.length &amp;&amp; !config.blocking ) {
		config.queue.shift()();
	}
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();

	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length &gt; 0 ) {
		ok( false, &quot;Introduced global variable(s): &quot; + newGlobals.join(&quot;, &quot;) );
		config.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length &gt; 0 ) {
		ok( false, &quot;Deleted global variable(s): &quot; + deletedGlobals.join(&quot;, &quot;) );
		config.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i &lt; result.length; i++ ) {
		for ( var j = 0; j &lt; b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== &quot;undefined&quot; &amp;&amp; console.error &amp;&amp; console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera &amp;&amp; opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( &quot;on&quot; + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== &quot;undefined&quot; &amp;&amp; document &amp;&amp; document.getElementById) &amp;&amp;
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rathé &lt;prathe@gmail.com&gt;
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions


    // Determine what is o.
    function hoozit(o) {
        if (o.constructor === String) {
            return &quot;string&quot;;

        } else if (o.constructor === Boolean) {
            return &quot;boolean&quot;;

        } else if (o.constructor === Number) {

            if (isNaN(o)) {
                return &quot;nan&quot;;
            } else {
                return &quot;number&quot;;
            }

        } else if (typeof o === &quot;undefined&quot;) {
            return &quot;undefined&quot;;

        // consider: typeof null === object
        } else if (o === null) {
            return &quot;null&quot;;

        // consider: typeof [] === object
        } else if (o instanceof Array) {
            return &quot;array&quot;;

        // consider: typeof new Date() === object
        } else if (o instanceof Date) {
            return &quot;date&quot;;

        // consider: /./ instanceof Object;
        //           /./ instanceof RegExp;
        //          typeof /./ === &quot;function&quot;; // =&gt; false in IE and Opera,
        //                                          true in FF and Safari
        } else if (o instanceof RegExp) {
            return &quot;regexp&quot;;

        } else if (typeof o === &quot;object&quot;) {
            return &quot;object&quot;;

        } else if (o instanceof Function) {
            return &quot;function&quot;;
        } else {
            return undefined;
        }
    }

    // Call the o related callback with the given arguments.
    function handleEvents(o, callbacks, args) {
        var prop = hoozit(o);
        if (prop) {
            if (hoozit(callbacks[prop]) === &quot;function&quot;) {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }

    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS &#039;new&#039; annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            &quot;string&quot;: useStrictEquality,
            &quot;boolean&quot;: useStrictEquality,
            &quot;number&quot;: useStrictEquality,
            &quot;null&quot;: useStrictEquality,
            &quot;undefined&quot;: useStrictEquality,

            &quot;nan&quot;: function (b) {
                return isNaN(b);
            },

            &quot;date&quot;: function (b, a) {
                return hoozit(b) === &quot;date&quot; &amp;&amp; a.valueOf() === b.valueOf();
            },

            &quot;regexp&quot;: function (b, a) {
                return hoozit(b) === &quot;regexp&quot; &amp;&amp;
                    a.source === b.source &amp;&amp; // the regex itself
                    a.global === b.global &amp;&amp; // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &amp;&amp;
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            &quot;function&quot;: function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &amp;&amp;
                        typeof caller !== &quot;undefined&quot;;
            },

            &quot;array&quot;: function (b, a) {
                var i;
                var len;

                // b could be an object literal here
                if ( ! (hoozit(b) === &quot;array&quot;)) {
                    return false;
                }

                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }
                for (i = 0; i &lt; len; i++) {
                    if ( ! innerEquiv(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            },

            &quot;object&quot;: function (b, a) {
                var i;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);

                for (i in a) { // be strict: don&#039;t ensures hasOwnProperty and go deep

                    aProperties.push(i); // collect a&#039;s properties

                    if ( ! innerEquiv(a[i], b[i])) {
                        eq = false;
                    }
                }

                callers.pop(); // unstack, we are done

                for (i in b) {
                    bProperties.push(i); // collect b&#039;s properties
                }

                // Ensures identical properties name
                return eq &amp;&amp; innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length &lt; 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === &quot;undefined&quot; || typeof b === &quot;undefined&quot; || hoozit(a) !== hoozit(b)) {
                return false; // don&#039;t lose time with error prone cases
            } else {
                return handleEvents(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) &amp;&amp; arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return &#039;&quot;&#039; + str.toString().replace(/&quot;/g, &#039;\\&quot;&#039;) + &#039;&quot;&#039;;
	};
	function literal( o ) {
		return o + &#039;&#039;;
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( &#039;,&#039; + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );
		this.down();
		return join( &#039;[&#039;, ret, &#039;]&#039; );
	};

	var reName = /^function (\w+)/;

	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;

			return type == &#039;function&#039; ? parser.call( this, obj ) :
				   type == &#039;string&#039; ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type = typeof obj,
				f = &#039;function&#039;;//we&#039;ll use it 3 times, save it
			return type != &#039;object&#039; &amp;&amp; type != f ? type :
				!obj ? &#039;null&#039; :
				obj.exec ? &#039;regexp&#039; :// some browsers (FF) consider regexps functions
				obj.getHours ? &#039;date&#039; :
				obj.scrollBy ?  &#039;window&#039; :
				obj.nodeName == &#039;#document&#039; ? &#039;document&#039; :
				obj.nodeName ? &#039;node&#039; :
				obj.item ? &#039;nodelist&#039; : // Safari reports nodelists as functions
				obj.callee ? &#039;arguments&#039; :
				obj.call || obj.constructor != Array &amp;&amp; //an array would also fall on this hack
					(obj+&#039;&#039;).indexOf(f) != -1 ? f : //IE reports functions like alert, as objects
				&#039;length&#039; in obj ? &#039;array&#039; :
				type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? &#039;&lt;br /&gt;&#039; : &#039;\n&#039; : this.HTML ? &#039;&amp;nbsp;&#039; : &#039; &#039;;
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return &#039;&#039;;
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,&#039;   &#039;).replace(/ /g,&#039;&amp;nbsp;&#039;);
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote,
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: &#039;[Window]&#039;,
			document: &#039;[Document]&#039;,
			error:&#039;[ERROR]&#039;, //when no parser is found, shouldn&#039;t happen
			unknown: &#039;[Unknown]&#039;,
			&#039;null&#039;:&#039;null&#039;,
			undefined:&#039;undefined&#039;,
			&#039;function&#039;:function( fn ) {
				var ret = &#039;function&#039;,
					name = &#039;name&#039; in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += &#039; &#039; + name;
				ret += &#039;(&#039;;

				ret = [ ret, this.parse( fn, &#039;functionArgs&#039; ), &#039;){&#039;].join(&#039;&#039;);
				return join( ret, this.parse(fn,&#039;functionCode&#039;), &#039;}&#039; );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				this.up();
				for ( var key in map )
					ret.push( this.parse(key,&#039;key&#039;) + &#039;: &#039; + this.parse(map[key]) );
				this.down();
				return join( &#039;{&#039;, ret, &#039;}&#039; );
			},
			node:function( node ) {
				var open = this.HTML ? &#039;&amp;lt;&#039; : &#039;&lt;&#039;,
					close = this.HTML ? &#039;&amp;gt;&#039; : &#039;&gt;&#039;;

				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;

				for ( var a in this.DOMAttrs ) {
					var val = node[this.DOMAttrs[a]];
					if ( val )
						ret += &#039; &#039; + a + &#039;=&#039; + this.parse( val, &#039;attribute&#039; );
				}
				return ret + close + open + &#039;/&#039; + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it&#039;s the arguments part of the function
				var l = fn.length;
				if ( !l ) return &#039;&#039;;

				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is &#039;a&#039;
				return &#039; &#039; + args.join(&#039;, &#039;) + &#039; &#039;;
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:&#039;[code]&#039;, //function calls it internally, it&#039;s the content of the function
			attribute:quote, //node calls it internally, it&#039;s an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			&#039;boolean&#039;:literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=&gt;realName
			id:&#039;id&#039;,
			name:&#039;name&#039;,
			&#039;class&#039;:&#039;className&#039;
		},
		HTML:true,//if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
		indentChar:&#039;   &#039;,//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

})(this);/*
 * QUnit - A JavaScript Unit Testing Framework
 *
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2009 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== &quot;undefined&quot;,
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e){
			return false;
		}
  })()
}

var testId = 0;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id(&quot;qunit-tests&quot;);
		if (tests) {
			var b = document.createElement(&quot;strong&quot;);
				b.innerHTML = &quot;Running &quot; + this.name;
			var li = document.createElement(&quot;li&quot;);
				li.appendChild( b );
				li.id = this.id = &quot;test-output&quot; + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( this.previousModule ) {
				QUnit.moduleDone( this.module, config.moduleStats.bad, config.moduleStats.all );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			QUnit.moduleStart( this.module, this.moduleTestEnvironment );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		QUnit.testStart( this.testName, this.testEnvironment );

		// allow utility functions to access the current test environment
		// TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;

		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			// TODO use testName instead of name for no-markup message?
			QUnit.ok( false, &quot;Setup failed on &quot; + this.name + &quot;: &quot; + e.message );
		}
	},
	run: function() {
		if ( this.async ) {
			QUnit.stop();
		}

		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			// TODO use testName instead of name for no-markup message?
			fail(&quot;Test &quot; + this.name + &quot; died, exception and test follows&quot;, e, this.callback);
			QUnit.ok( false, &quot;Died on test #&quot; + (this.assertions.length + 1) + &quot;: &quot; + e.message + &quot; - &quot; + QUnit.jsDump.parse(e) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they&#039;re blocking
			if ( config.blocking ) {
				start();
			}
		}
	},
	teardown: function() {
		try {
			checkPollution();
			this.testEnvironment.teardown.call(this.testEnvironment);
		} catch(e) {
			// TODO use testName instead of name for no-markup message?
			QUnit.ok( false, &quot;Teardown failed on &quot; + this.name + &quot;: &quot; + e.message );
		}
	},
	finish: function() {
		if ( this.expected &amp;&amp; this.expected != this.assertions.length ) {
			QUnit.ok( false, &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; + this.assertions.length + &quot; were run&quot; );
		}

		var good = 0, bad = 0,
			tests = id(&quot;qunit-tests&quot;);

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol  = document.createElement(&quot;ol&quot;);

			for ( var i = 0; i &lt; this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement(&quot;li&quot;);
				li.className = assertion.result ? &quot;pass&quot; : &quot;fail&quot;;
				li.innerHTML = assertion.message || (assertion.result ? &quot;okay&quot; : &quot;failed&quot;);
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			defined.sessionStorage &amp;&amp; sessionStorage.setItem(&quot;qunit-&quot; + this.testName, bad);

			if (bad == 0) {
				ol.style.display = &quot;none&quot;;
			}

			var b = document.createElement(&quot;strong&quot;);
			b.innerHTML = this.name + &quot; &lt;b class=&#039;counts&#039;&gt;(&lt;b class=&#039;failed&#039;&gt;&quot; + bad + &quot;&lt;/b&gt;, &lt;b class=&#039;passed&#039;&gt;&quot; + good + &quot;&lt;/b&gt;, &quot; + this.assertions.length + &quot;)&lt;/b&gt;&quot;;

			addEvent(b, &quot;click&quot;, function() {
				var next = b.nextSibling, display = next.style.display;
				next.style.display = display === &quot;none&quot; ? &quot;block&quot; : &quot;none&quot;;
			});

			addEvent(b, &quot;dblclick&quot;, function(e) {
				var target = e &amp;&amp; e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == &quot;span&quot; || target.nodeName.toLowerCase() == &quot;b&quot; ) {
					target = target.parentNode;
				}
				if ( window.location &amp;&amp; target.nodeName.toLowerCase() === &quot;strong&quot; ) {
					window.location.search = &quot;?&quot; + encodeURIComponent(getText([target]).replace(/\(.+\)$/, &quot;&quot;).replace(/(^\s*|\s*$)/g, &quot;&quot;));
				}
			});

			var li = id(this.id);
			li.className = bad ? &quot;fail&quot; : &quot;pass&quot;;
			li.style.display = resultDisplayStyle(!bad);
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( ol );

			if ( bad ) {
				var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
				if ( toolbar ) {
					toolbar.style.display = &quot;block&quot;;
					id(&quot;qunit-filter-pass&quot;).disabled = null;
				}
			}

		} else {
			for ( var i = 0; i &lt; this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			// TODO use testName instead of name for no-markup message?
			fail(&quot;reset() failed, following Test &quot; + this.name + &quot;, exception and reset fn follows&quot;, e, QUnit.reset);
		}

		QUnit.testDone( this.testName, bad, this.assertions.length );
	},

	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		// defer when previous test run passed, if storage is available
		var bad = defined.sessionStorage &amp;&amp; +sessionStorage.getItem(&quot;qunit-&quot; + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run);
		};
	}

}

var QUnit = {

	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.previousModule = config.currentModule;
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},

	test: function(testName, expected, callback, async) {
		var name = &#039;&lt;span class=&quot;test-name&quot;&gt;&#039; + testName + &#039;&lt;/span&gt;&#039;, testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		// is 2nd argument a testEnvironment?
		if ( expected &amp;&amp; typeof expected === &#039;object&#039;) {
			testEnvironmentArg =  expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = &#039;&lt;span class=&quot;module-name&quot;&gt;&#039; + config.currentModule + &quot;&lt;/span&gt;: &quot; + name;
		}

		if ( !validTest(config.currentModule + &quot;: &quot; + testName) ) {
			return;
		}

		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.previousModule = config.previousModule;
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},

	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don&#039;t slip through.
	 */
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( &quot;asdfasdf&quot;.length &gt; 5, &quot;There must be at least 5 chars&quot; );
	 */
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeHtml(msg);
		QUnit.log(a, msg, details);
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format(&quot;Received {0} bytes.&quot;, 2), &quot;Received 2 bytes.&quot; );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},

	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;

		if (typeof expected === &#039;string&#039;) {
			message = expected;
			expected = null;
		}

		try {
			block();
		} catch (e) {
			actual = e;
		}

		if (actual) {
			// we don&#039;t want to validate thrown error
			if (!expected) {
				ok = true;
			// expected is a regexp
			} else if (QUnit.objectType(expected) === &quot;regexp&quot;) {
				ok = expected.test(actual);
			// expected is a constructor
			} else if (actual instanceof expected) {
				ok = true;
			// expected is a validation function which returns true is validation passed
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}

		QUnit.ok(ok, message);
	},

	start: function() {
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},

	stop: function(timeout) {
		config.blocking = true;

		if ( timeout &amp;&amp; defined.setTimeout ) {
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, &quot;Test timed out&quot; );
				QUnit.start();
			}, timeout);
		}
	}

};

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: &quot;&quot;, protocol: &quot;file:&quot; },
		GETParams = location.search.slice(1).split(&#039;&amp;&#039;);

	for ( var i = 0; i &lt; GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === &quot;noglobals&quot; ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		} else if ( GETParams[i].search(&#039;=&#039;) &gt; -1 ) {
			GETParams.splice( i, 1 );
			i--;
		}
	}

	// restrict modules/tests by get parameters
	config.filters = GETParams;

	// Figure out if we&#039;re running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === &#039;file:&#039;);
})();

// Expose the API as global variables, unless an &#039;exports&#039;
// object exists, in that case we assume we&#039;re in CommonJS
if ( typeof exports === &quot;undefined&quot; || typeof require === &quot;undefined&quot; ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	// Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filters: [],
			queue: []
		});

		var tests = id(&quot;qunit-tests&quot;),
			banner = id(&quot;qunit-banner&quot;),
			result = id(&quot;qunit-testresult&quot;);

		if ( tests ) {
			tests.innerHTML = &quot;&quot;;
		}

		if ( banner ) {
			banner.className = &quot;&quot;;
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},

	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 *
	 * If jQuery is available, uses jQuery&#039;s html(), otherwise just innerHTML.
	 */
	reset: function() {
		if ( window.jQuery ) {
			jQuery( &quot;#main, #qunit-fixture&quot; ).html( config.fixture );
		} else {
			var main = id( &#039;main&#039; ) || id( &#039;qunit-fixture&#039; );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},

	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, &quot;click&quot; );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent(&quot;MouseEvents&quot;);
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent(&quot;on&quot;+type);
		}
	},

	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},

	objectType: function( obj ) {
		if (typeof obj === &quot;undefined&quot;) {
				return &quot;undefined&quot;;

		// consider: typeof null === object
		}
		if (obj === null) {
				return &quot;null&quot;;
		}

		var type = Object.prototype.toString.call( obj )
			.match(/^\[object\s(.*)\]$/)[1] || &#039;&#039;;

		switch (type) {
				case &#039;Number&#039;:
						if (isNaN(obj)) {
								return &quot;nan&quot;;
						} else {
								return &quot;number&quot;;
						}
				case &#039;String&#039;:
				case &#039;Boolean&#039;:
				case &#039;Array&#039;:
				case &#039;Date&#039;:
				case &#039;RegExp&#039;:
				case &#039;Function&#039;:
						return type.toLowerCase();
		}
		if (typeof obj === &quot;object&quot;) {
				return &quot;object&quot;;
		}
		return undefined;
	},

	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};

		message = escapeHtml(message) || (result ? &quot;okay&quot; : &quot;failed&quot;);
		message = &#039;&lt;span class=&quot;test-message&quot;&gt;&#039; + message + &quot;&lt;/span&gt;&quot;;
		expected = escapeHtml(QUnit.jsDump.parse(expected));
		actual = escapeHtml(QUnit.jsDump.parse(actual));
		var output = message + &#039;&lt;table&gt;&lt;tr class=&quot;test-expected&quot;&gt;&lt;th&gt;Expected: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#039; + expected + &#039;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#039;;
		if (actual != expected) {
			output += &#039;&lt;tr class=&quot;test-actual&quot;&gt;&lt;th&gt;Result: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#039; + actual + &#039;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#039;;
			output += &#039;&lt;tr class=&quot;test-diff&quot;&gt;&lt;th&gt;Diff: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#039; + QUnit.diff(expected, actual) +&#039;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#039;;
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += &#039;&lt;tr class=&quot;test-source&quot;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#039; + source +&#039;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#039;;
			}
		}
		output += &quot;&lt;/table&gt;&quot;;

		QUnit.log(result, message, details);

		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},

	// Logging callbacks
	begin: function() {},
	done: function(failures, total) {},
	log: function(result, message) {},
	testStart: function(name, testEnvironment) {},
	testDone: function(name, failures, total) {},
	moduleStart: function(name, testEnvironment) {},
	moduleDone: function(name, failures, total) {}
});

if ( typeof document === &quot;undefined&quot; || document.readyState === &quot;complete&quot; ) {
	config.autorun = true;
}

addEvent(window, &quot;load&quot;, function() {
	QUnit.begin();

	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id(&quot;qunit-userAgent&quot;);
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id(&quot;qunit-header&quot;);
	if ( banner ) {
		var paramsIndex = location.href.lastIndexOf(location.search);
		if ( paramsIndex &gt; -1 ) {
			var mainPageLocation = location.href.slice(0, paramsIndex);
			if ( mainPageLocation == location.href ) {
				banner.innerHTML = &#039;&lt;a href=&quot;&quot;&gt; &#039; + banner.innerHTML + &#039;&lt;/a&gt; &#039;;
			} else {
				var testName = decodeURIComponent(location.search.slice(1));
				banner.innerHTML = &#039;&lt;a href=&quot;&#039; + mainPageLocation + &#039;&quot;&gt;&#039; + banner.innerHTML + &#039;&lt;/a&gt; &amp;#8250; &lt;a href=&quot;&quot;&gt;&#039; + testName + &#039;&lt;/a&gt;&#039;;
			}
		}
	}

	var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
	if ( toolbar ) {
		toolbar.style.display = &quot;none&quot;;

		var filter = document.createElement(&quot;input&quot;);
		filter.type = &quot;checkbox&quot;;
		filter.id = &quot;qunit-filter-pass&quot;;
		filter.disabled = true;
		addEvent( filter, &quot;click&quot;, function() {
			var li = document.getElementsByTagName(&quot;li&quot;);
			for ( var i = 0; i &lt; li.length; i++ ) {
				if ( li[i].className.indexOf(&quot;pass&quot;) &gt; -1 ) {
					li[i].style.display = filter.checked ? &quot;none&quot; : &quot;&quot;;
				}
			}
		});
		toolbar.appendChild( filter );

		var label = document.createElement(&quot;label&quot;);
		label.setAttribute(&quot;for&quot;, &quot;qunit-filter-pass&quot;);
		label.innerHTML = &quot;Hide passed tests&quot;;
		toolbar.appendChild( label );
	}

	var main = id(&#039;main&#039;) || id(&#039;qunit-fixture&#039;);
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
});

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all );
	}

	var banner = id(&quot;qunit-banner&quot;),
		tests = id(&quot;qunit-tests&quot;),
		html = [&#039;Tests completed in &#039;,
		+new Date - config.started, &#039; milliseconds.&lt;br/&gt;&#039;,
		&#039;&lt;span class=&quot;passed&quot;&gt;&#039;, config.stats.all - config.stats.bad, &#039;&lt;/span&gt; tests of &lt;span class=&quot;total&quot;&gt;&#039;, config.stats.all, &#039;&lt;/span&gt; passed, &lt;span class=&quot;failed&quot;&gt;&#039;, config.stats.bad,&#039;&lt;/span&gt; failed.&#039;].join(&#039;&#039;);

	if ( banner ) {
		banner.className = (config.stats.bad ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot;);
	}

	if ( tests ) {
		var result = id(&quot;qunit-testresult&quot;);

		if ( !result ) {
			result = document.createElement(&quot;p&quot;);
			result.id = &quot;qunit-testresult&quot;;
			result.className = &quot;result&quot;;
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( config.stats.bad, config.stats.all );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}

	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == &#039;!&#039;;

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			// Opera
			return e.stacktrace.split(&quot;\n&quot;)[6];
		} else if (e.stack) {
			// Firefox, Chrome
			return e.stack.split(&quot;\n&quot;)[4];
		}
	}
}

function resultDisplayStyle(passed) {
	return passed &amp;&amp; id(&quot;qunit-filter-pass&quot;) &amp;&amp; id(&quot;qunit-filter-pass&quot;).checked ? &#039;none&#039; : &#039;&#039;;
}

function escapeHtml(s) {
	if (!s) {
		return &quot;&quot;;
	}
	s = s + &quot;&quot;;
	return s.replace(/[\&amp;&quot;&lt;&gt;\\]/g, function(s) {
		switch(s) {
			case &quot;&amp;&quot;: return &quot;&amp;amp;&quot;;
			case &quot;\\&quot;: return &quot;\\\\&quot;;
			case &#039;&quot;&#039;: return &#039;\&quot;&#039;;
			case &quot;&lt;&quot;: return &quot;&amp;lt;&quot;;
			case &quot;&gt;&quot;: return &quot;&amp;gt;&quot;;
			default: return s;
		}
	});
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun &amp;&amp; !config.blocking ) {
		process();
	}
}

function process() {
	var start = (new Date()).getTime();

	while ( config.queue.length &amp;&amp; !config.blocking ) {
		if ( config.updateRate &lt;= 0 || (((new Date()).getTime() - start) &lt; config.updateRate) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( process, 13 );
			break;
		}
	}
  if (!config.blocking &amp;&amp; !config.queue.length) {
    done();
  }
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();

	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length &gt; 0 ) {
		ok( false, &quot;Introduced global variable(s): &quot; + newGlobals.join(&quot;, &quot;) );
		config.current.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length &gt; 0 ) {
		ok( false, &quot;Deleted global variable(s): &quot; + deletedGlobals.join(&quot;, &quot;) );
		config.current.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i &lt; result.length; i++ ) {
		for ( var j = 0; j &lt; b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== &quot;undefined&quot; &amp;&amp; console.error &amp;&amp; console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera &amp;&amp; opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( &quot;on&quot; + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== &quot;undefined&quot; &amp;&amp; document &amp;&amp; document.getElementById) &amp;&amp;
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rathé &lt;prathe@gmail.com&gt;
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions
    var parents = []; // stack to avoiding loops from circular referencing

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) {
        var prop = QUnit.objectType(o);
        if (prop) {
            if (QUnit.objectType(callbacks[prop]) === &quot;function&quot;) {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }

    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS &#039;new&#039; annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            &quot;string&quot;: useStrictEquality,
            &quot;boolean&quot;: useStrictEquality,
            &quot;number&quot;: useStrictEquality,
            &quot;null&quot;: useStrictEquality,
            &quot;undefined&quot;: useStrictEquality,

            &quot;nan&quot;: function (b) {
                return isNaN(b);
            },

            &quot;date&quot;: function (b, a) {
                return QUnit.objectType(b) === &quot;date&quot; &amp;&amp; a.valueOf() === b.valueOf();
            },

            &quot;regexp&quot;: function (b, a) {
                return QUnit.objectType(b) === &quot;regexp&quot; &amp;&amp;
                    a.source === b.source &amp;&amp; // the regex itself
                    a.global === b.global &amp;&amp; // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &amp;&amp;
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            &quot;function&quot;: function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &amp;&amp;
                        typeof caller !== &quot;undefined&quot;;
            },

            &quot;array&quot;: function (b, a) {
                var i, j, loop;
                var len;

                // b could be an object literal here
                if ( ! (QUnit.objectType(b) === &quot;array&quot;)) {
                    return false;
                }

                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }

                //track reference to avoid circular references
                parents.push(a);
                for (i = 0; i &lt; len; i++) {
                    loop = false;
                    for(j=0;j&lt;parents.length;j++){
                        if(parents[j] === a[i]){
                            loop = true;//dont rewalk array
                        }
                    }
                    if (!loop &amp;&amp; ! innerEquiv(a[i], b[i])) {
                        parents.pop();
                        return false;
                    }
                }
                parents.pop();
                return true;
            },

            &quot;object&quot;: function (b, a) {
                var i, j, loop;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);
                //track reference to avoid circular references
                parents.push(a);

                for (i in a) { // be strict: don&#039;t ensures hasOwnProperty and go deep
                    loop = false;
                    for(j=0;j&lt;parents.length;j++){
                        if(parents[j] === a[i])
                            loop = true; //don&#039;t go down the same path twice
                    }
                    aProperties.push(i); // collect a&#039;s properties

                    if (!loop &amp;&amp; ! innerEquiv(a[i], b[i])) {
                        eq = false;
                        break;
                    }
                }

                callers.pop(); // unstack, we are done
                parents.pop();

                for (i in b) {
                    bProperties.push(i); // collect b&#039;s properties
                }

                // Ensures identical properties name
                return eq &amp;&amp; innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length &lt; 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === &quot;undefined&quot; || typeof b === &quot;undefined&quot; || QUnit.objectType(a) !== QUnit.objectType(b)) {
                return false; // don&#039;t lose time with error prone cases
            } else {
                return bindCallbacks(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) &amp;&amp; arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return &#039;&quot;&#039; + str.toString().replace(/&quot;/g, &#039;\\&quot;&#039;) + &#039;&quot;&#039;;
	};
	function literal( o ) {
		return o + &#039;&#039;;
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( &#039;,&#039; + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );
		this.down();
		return join( &#039;[&#039;, ret, &#039;]&#039; );
	};

	var reName = /^function (\w+)/;

	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;

			return type == &#039;function&#039; ? parser.call( this, obj ) :
				   type == &#039;string&#039; ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = &quot;null&quot;;
			} else if (typeof obj === &quot;undefined&quot;) {
				type = &quot;undefined&quot;;
			} else if (QUnit.is(&quot;RegExp&quot;, obj)) {
				type = &quot;regexp&quot;;
			} else if (QUnit.is(&quot;Date&quot;, obj)) {
				type = &quot;date&quot;;
			} else if (QUnit.is(&quot;Function&quot;, obj)) {
				type = &quot;function&quot;;
			} else if (typeof obj.setInterval !== undefined &amp;&amp; typeof obj.document !== &quot;undefined&quot; &amp;&amp; typeof obj.nodeType === &quot;undefined&quot;) {
				type = &quot;window&quot;;
			} else if (obj.nodeType === 9) {
				type = &quot;document&quot;;
			} else if (obj.nodeType) {
				type = &quot;node&quot;;
			} else if (typeof obj === &quot;object&quot; &amp;&amp; typeof obj.length === &quot;number&quot; &amp;&amp; obj.length &gt;= 0) {
				type = &quot;array&quot;;
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? &#039;&lt;br /&gt;&#039; : &#039;\n&#039; : this.HTML ? &#039;&amp;nbsp;&#039; : &#039; &#039;;
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return &#039;&#039;;
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,&#039;   &#039;).replace(/ /g,&#039;&amp;nbsp;&#039;);
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote,
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: &#039;[Window]&#039;,
			document: &#039;[Document]&#039;,
			error:&#039;[ERROR]&#039;, //when no parser is found, shouldn&#039;t happen
			unknown: &#039;[Unknown]&#039;,
			&#039;null&#039;:&#039;null&#039;,
			undefined:&#039;undefined&#039;,
			&#039;function&#039;:function( fn ) {
				var ret = &#039;function&#039;,
					name = &#039;name&#039; in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += &#039; &#039; + name;
				ret += &#039;(&#039;;

				ret = [ ret, QUnit.jsDump.parse( fn, &#039;functionArgs&#039; ), &#039;){&#039;].join(&#039;&#039;);
				return join( ret, QUnit.jsDump.parse(fn,&#039;functionCode&#039;), &#039;}&#039; );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map )
					ret.push( QUnit.jsDump.parse(key,&#039;key&#039;) + &#039;: &#039; + QUnit.jsDump.parse(map[key]) );
				QUnit.jsDump.down();
				return join( &#039;{&#039;, ret, &#039;}&#039; );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? &#039;&amp;lt;&#039; : &#039;&lt;&#039;,
					close = QUnit.jsDump.HTML ? &#039;&amp;gt;&#039; : &#039;&gt;&#039;;

				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;

				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += &#039; &#039; + a + &#039;=&#039; + QUnit.jsDump.parse( val, &#039;attribute&#039; );
				}
				return ret + close + open + &#039;/&#039; + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it&#039;s the arguments part of the function
				var l = fn.length;
				if ( !l ) return &#039;&#039;;

				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is &#039;a&#039;
				return &#039; &#039; + args.join(&#039;, &#039;) + &#039; &#039;;
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:&#039;[code]&#039;, //function calls it internally, it&#039;s the content of the function
			attribute:quote, //node calls it internally, it&#039;s an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			&#039;boolean&#039;:literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=&gt;realName
			id:&#039;id&#039;,
			name:&#039;name&#039;,
			&#039;class&#039;:&#039;className&#039;
		},
		HTML:false,//if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
		indentChar:&#039;  &#039;,//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

// from Sizzle.js
function getText( elems ) {
	var ret = &quot;&quot;, elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan &quot;sprite&quot;
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *
 * Usage: QUnit.diff(expected, actual)
 *
 * QUnit.diff(&quot;the quick brown fox jumped over&quot;, &quot;the quick fox jumps over&quot;) == &quot;the  quick &lt;del&gt;brown &lt;/del&gt; fox &lt;del&gt;jumped &lt;/del&gt;&lt;ins&gt;jumps &lt;/ins&gt; over&quot;
 */
QUnit.diff = (function() {
	function diff(o, n){
		var ns = new Object();
		var os = new Object();

		for (var i = 0; i &lt; n.length; i++) {
			if (ns[n[i]] == null)
				ns[n[i]] = {
					rows: new Array(),
					o: null
				};
			ns[n[i]].rows.push(i);
		}

		for (var i = 0; i &lt; o.length; i++) {
			if (os[o[i]] == null)
				os[o[i]] = {
					rows: new Array(),
					n: null
				};
			os[o[i]].rows.push(i);
		}

		for (var i in ns) {
			if (ns[i].rows.length == 1 &amp;&amp; typeof(os[i]) != &quot;undefined&quot; &amp;&amp; os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}

		for (var i = 0; i &lt; n.length - 1; i++) {
			if (n[i].text != null &amp;&amp; n[i + 1].text == null &amp;&amp; n[i].row + 1 &lt; o.length &amp;&amp; o[n[i].row + 1].text == null &amp;&amp;
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}

		for (var i = n.length - 1; i &gt; 0; i--) {
			if (n[i].text != null &amp;&amp; n[i - 1].text == null &amp;&amp; n[i].row &gt; 0 &amp;&amp; o[n[i].row - 1].text == null &amp;&amp;
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}

		return {
			o: o,
			n: n
		};
	}

	return function(o, n){
		o = o.replace(/\s+$/, &#039;&#039;);
		n = n.replace(/\s+$/, &#039;&#039;);
		var out = diff(o == &quot;&quot; ? [] : o.split(/\s+/), n == &quot;&quot; ? [] : n.split(/\s+/));

		var str = &quot;&quot;;

		var oSpace = o.match(/\s+/g);
		if (oSpace == null) {
			oSpace = [&quot; &quot;];
		}
		else {
			oSpace.push(&quot; &quot;);
		}
		var nSpace = n.match(/\s+/g);
		if (nSpace == null) {
			nSpace = [&quot; &quot;];
		}
		else {
			nSpace.push(&quot; &quot;);
		}

		if (out.n.length == 0) {
			for (var i = 0; i &lt; out.o.length; i++) {
				str += &#039;&lt;del&gt;&#039; + out.o[i] + oSpace[i] + &quot;&lt;/del&gt;&quot;;
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
					str += &#039;&lt;del&gt;&#039; + out.o[n] + oSpace[n] + &quot;&lt;/del&gt;&quot;;
				}
			}

			for (var i = 0; i &lt; out.n.length; i++) {
				if (out.n[i].text == null) {
					str += &#039;&lt;ins&gt;&#039; + out.n[i] + nSpace[i] + &quot;&lt;/ins&gt;&quot;;
				}
				else {
					var pre = &quot;&quot;;

					for (n = out.n[i].row + 1; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
						pre += &#039;&lt;del&gt;&#039; + out.o[n] + oSpace[n] + &quot;&lt;/del&gt;&quot;;
					}
					str += &quot; &quot; + out.n[i].text + nSpace[i] + pre;
				}
			}
		}

		return str;
	};
})();

})(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
